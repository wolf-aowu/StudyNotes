### 图形绘制过程

在 Unity 中，每次绘制前 CPU 都需要做很多处理工作：确定哪些光源影响该对象，设置着色器和着色器参数，向图形驱动程序发送绘制命令，而图形驱动程序随后将准备发送到 显卡 的命令。显卡 收到命令后，GPU会开始图形渲染。

### 影响图形性能的主要因素

游戏的图形部分主要影响计算机的两个系统：CPU 和 GPU。CPU 和 GPU 的优化策略大不相同，优化 CPU 则让 GPU 做更多的工作，优化 GPU 则让 CPU 做更多的工作。

瓶颈及检查方法：

- GPU 
  - 受填充率或内存带宽制约。降低显示分辨率并运行游戏。如果显示分辨率降低后游戏运行更快，表明 GPU 填充率可能是限制因素。
  - GPU 有太多顶点需要处理。可接受的能确保良好性能的顶点数量取决于 GPU 和顶点着色器的复杂程度。一般来说，移动端应不超过 100,000 个顶点。另一方面，即使有数百万个顶点，PC 也能管理到位，不过最好还是通过优化尽可能减少此数量。
- CPU 
  - 受到需要渲染的批次数的限制。检查 Rendering Statistics 窗口中的 batches。渲染的批次越多，CPU 成本越高。
  - CPU 有太多顶点需要处理。这些顶点可能位于蒙皮网格、布料模拟、粒子或其他游戏对象和网格中。如上所述，通常较好的做法是在不影响游戏质量的情况下尽可能降低此数量。
- 其他问题
  - 如 脚本 和 物理系统 中，这些可以通过 Unity Profiler 找出。

### CPU 优化

<font color = teal>情况说明及优化依据</font>

GPU 的处理速度一般比 CPU 的处理速度快，但是每次绘制前都需要 CPU 先做处理工作，一旦渲染的批次变多，CPU 就要大量做绘制前的处理工作，加重了 CPU 的工作负担，也就导致 CPU 卡顿。

例如：如果有一千个三角形，如果它们都在一个网格中，而不是每个三角形在一个网格中（这种情况下加起来就有 1000 个网格），则 CPU 处理起来就比较容易。两种方案的 GPU 成本非常相似，但 CPU 完成渲染一千个对象（而不是一个）的工作要高得多。

<font color = teal>优化</font>

- 减少可见对象数量。

- 通过手动方式或使用 Unity 的绘制调用批处理将近处对象组合在一起。

  绘制调用批处理的前提：使用相同纹理 (Texture) 和 材质 (Marterial)。Unity 会自动组合。

- 通过将单独的纹理放入更大的纹理图集，在对象中使用更少的材质。

  一个 Canvas 中的图片尽量放在一个图集 (Sprite Altas) 内，图集不同会影响 batches。

- 减少可能导致对象多次渲染的因素（例如反射、阴影和每像素光照）。

- 在暂停菜单、等待玩家行动等 场景相对简单 或 内容大多为静态 或 活动较低的时间段 中可以使用 OnDemandRendering 降低帧率来防止移动设备温度升高、延长设备电池续航时间等。

  OnDemandRendering 在 Android 上与 Optimized Frame Pacing（优化帧的速率）一起使用时需注意：

  - 如果还使用 OpenGL ES，则 Optimized Frame Pacing 在帧率为 20、30 或 60 帧/秒时效果最好。若要确保以其中一个帧率进行渲染，请使用 OnDemandRendering.effectiveRenderFrameRate。
  - Vulkan 不那么严格，可使用更多数量的有效帧率。
  - 如果请求使用不兼容的帧率，则应用程序会以尽可能快的速度进行渲染。另请注意，太高的 renderFrameInterval 可能会导致应用程序无响应，因为渲染帧之间的时间太长。

  <font color = #9c88ff>更多关于 OnDemandRendering 见 Unity 官网。</font>

### GPU 优化

<font color = teal>优化</font>

- 模型几何体

  - 除非必要，否则不要使用三角形

  - 尽可能降低 UV 贴图接缝和硬边（双倍顶点）的数量。

- 光照性能，可以使用光照贴图。<font color = #9c88ff>更多关于光照性能见 Unity 官网 优化图形性能。</font>

- 压缩纹理

  使用压缩纹理可减小纹理的大小。这种做法可加快加载时间、减小内存占用并显著提高渲染性能。与未压缩的 32 位 RGBA 纹理所需的内存带宽相比，压缩纹理使用的内存带宽要小得多。

- 纹理 Mipmap

  对于 3D 场景中使用的纹理，应始终启用 Generate mipmaps 选项。Mipmap 纹理使 GPU 能够为较小的三角形使用较低分辨率的纹理。这一点类似于纹理压缩可以帮助限制 GPU 渲染时传输的纹理数据量。

  此规则的唯一例外是当已知纹理像素将 1:1 映射到渲染的屏幕像素时（与 UI 元素或在 2D 游戏中一样）。

- LOD（细节级别）和每层剔除距离

  剔除对象涉及使对象不可见。这是减轻 CPU 和 GPU 负载的有效方法。

  在许多游戏中，在不影响玩家体验的情况下快速有效地执行此操作的方法是，相对于大对象，更激进地剔除小对象。例如，可让远处的小岩石和碎片不可见，而大型建筑物仍然保持可见。

  有多种方式实现此目标：

  - 使用细节级别系统

  - 手动设置摄像机上的每层剔除距离

  - 将小对象放入单独一层，并使用 Camera.layerCullDistances 脚本函数设置每层剔除距离

- 实时阴影，对性能能有很大影响，同时会增加 CPU 的绘制调用次数和 GPU 的处理量。

- 编写高性能着色器的技巧。<font color = #9c88ff>更多关于高性能着色器技巧见 Unity 官网 优化图形性能。</font>

### 用于提高游戏运行速度的简单核对表

- 在针对 PC 平台进行构建时，保持顶点数量低于 200K 和 3M/帧（具体值取决于目标 GPU）。
- 如果要使用内置着色器，请从 **Mobile** 或 **Unlit** 类别中选取。这些类别也适用于非移动平台，但它们是更复杂着色器的简化和近似版本。
- 保持每个场景使用较少的不同材质，并尽可能在不同对象之间共享材质。
- 在非移动对象上设置 `Static` 属性以便允许内部优化，如静态批处理。
- 只有一个（最好是方向性的）`pixel light` 影响几何体（而不是有多个）。
- 烘焙光照而不是使用动态光照。
- 尽可能使用压缩纹理格式，并使用 16 位纹理而非 32 位纹理。
- 尽可能避免使用雾效。
- 如果复杂的静态场景具有大量遮挡，使用遮挡剔除减少可见几何体数量和绘制调用次数。设计关卡时注意遮挡剔除。
- 使用天空盒“伪造”远处的几何体。
- 使用像素着色器或纹理组合器来混合多个纹理而不是使用多 pass 方法。
- 尽可能使用 `half` 精度变量。
- 最大限度减少在像素着色器中使用复杂的数学运算，例如 `pow`、`sin` 和 `cos`。
- 每个片元使用更少的纹理。